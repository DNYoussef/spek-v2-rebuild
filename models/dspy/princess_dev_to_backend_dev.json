{
  "delegate.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "phase": "implement-api",
        "context": "{\"previous_phase\": \"design\", \"api_spec\": \"User authentication with JWT tokens\", \"database\": \"PostgreSQL with Prisma ORM\", \"framework\": \"Express.js + TypeScript\"}",
        "reasoning": "For implementing user authentication with JWT tokens, I'll assign this to a backend-dev drone since it involves API development, security implementation, and database integration. The task requires careful handling of authentication flows, token management, and security best practices. The drone will need to implement user registration, login endpoints, JWT token generation/validation, and secure password handling.",
        "drone_task": "{\n  \"drone_id\": \"backend-dev\",\n  \"task_type\": \"implement-authentication\",\n  \"description\": \"Implement JWT-based user authentication system\",\n  \"payload\": {\n    \"endpoints\": [\n      {\"path\": \"/api/auth/register\", \"method\": \"POST\"},\n      {\"path\": \"/api/auth/login\", \"method\": \"POST\"},\n      {\"path\": \"/api/auth/refresh\", \"method\": \"POST\"},\n      {\"path\": \"/api/auth/logout\", \"method\": \"POST\"}\n    ],\n    \"features\": [\n      \"password hashing with bcrypt\",\n      \"JWT token generation and validation\",\n      \"refresh token rotation\",\n      \"secure cookie handling\",\n      \"rate limiting\"\n    ],\n    \"security\": {\n      \"password_requirements\": \"min 8 chars, 1 uppercase, 1 number, 1 special\",\n      \"token_expiry\": {\"access\": \"15m\", \"refresh\": \"7d\"},\n      \"rate_limits\": {\"login\": \"5 per minute\", \"register\": \"3 per minute\"}\n    }\n  },\n  \"acceptance_criteria\": [\n    \"All endpoints return proper HTTP status codes and error messages\",\n    \"Passwords are securely hashed before storage\",\n    \"JWT tokens include proper claims and expiration\",\n    \"Refresh token rotation prevents replay attacks\",\n    \"Input validation prevents injection attacks\",\n    \"Rate limiting prevents brute force attempts\",\n    \"Authentication middleware correctly validates tokens\",\n    \"Test coverage > 90% for authentication logic\"\n  ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-crud",
        "context": "{\"previous_phase\": \"architecture\", \"api_spec\": \"Product catalog CRUD with pagination\", \"database\": \"MongoDB with Mongoose\", \"framework\": \"NestJS + TypeScript\"}",
        "reasoning": "For implementing a CRUD API for a product catalog, I'll assign this to a backend-dev drone. The task requires TypeScript expertise, NestJS framework knowledge, and MongoDB/Mongoose experience. The implementation needs to follow REST best practices with proper pagination, validation, and error handling. The drone will need to create DTOs, service layer, and controller with proper separation of concerns.",
        "drone_task": "{\n  \"drone_id\": \"backend-dev\",\n  \"task_type\": \"implement-crud\",\n  \"description\": \"Implement RESTful CRUD endpoints for product catalog with pagination\",\n  \"payload\": {\n    \"endpoints\": [\n      {\"method\": \"GET\", \"path\": \"/api/products\", \"query\": \"page, limit, sort, filter\"},\n      {\"method\": \"GET\", \"path\": \"/api/products/:id\"},\n      {\"method\": \"POST\", \"path\": \"/api/products\"},\n      {\"method\": \"PUT\", \"path\": \"/api/products/:id\"},\n      {\"method\": \"DELETE\", \"path\": \"/api/products/:id\"}\n    ],\n    \"models\": {\n      \"required_fields\": [\"name\", \"description\", \"price\", \"category\", \"sku\"],\n      \"optional_fields\": [\"images\", \"tags\", \"metadata\"]\n    },\n    \"validation\": \"class-validator decorators\",\n    \"pagination\": {\n      \"default_limit\": 20,\n      \"max_limit\": 100,\n      \"sort_fields\": [\"name\", \"price\", \"createdAt\"]\n    },\n    \"error_handling\": \"proper HTTP status codes and error messages\"\n  },\n  \"acceptance_criteria\": [\n    \"All CRUD operations implemented with proper validation\",\n    \"Pagination working with sort and filter options\",\n    \"TypeScript types/interfaces for all models\",\n    \"Unit tests covering all endpoints\",\n    \"Swagger/OpenAPI documentation generated\",\n    \"Error handling for all edge cases\",\n    \"Response times under 100ms for simple queries\"\n  ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-graphql",
        "context": "{\"previous_phase\": \"design\", \"api_spec\": \"GraphQL API for blog platform\", \"database\": \"PostgreSQL with TypeORM\", \"framework\": \"Apollo Server + TypeScript\"}",
        "reasoning": "For implementing a GraphQL API for a blog platform, I'll assign this to a backend-dev drone who specializes in API development. The task requires TypeScript expertise and GraphQL schema design. The drone will need to implement resolvers, types, and ensure proper database integration with TypeORM. Key focus areas will be type safety, N+1 query prevention, and proper error handling.",
        "drone_task": "{\n  \"drone_id\": \"backend-dev\",\n  \"task_type\": \"implement-graphql\",\n  \"description\": \"Implement GraphQL API for blog platform using Apollo Server and TypeScript\",\n  \"payload\": {\n    \"schema_types\": [\n      \"Post\", \n      \"User\", \n      \"Comment\",\n      \"Category\"\n    ],\n    \"operations\": {\n      \"queries\": [\"getPosts\", \"getPost\", \"getUser\", \"getComments\"],\n      \"mutations\": [\"createPost\", \"updatePost\", \"deletePost\", \"addComment\"]\n    },\n    \"features\": [\n      \"DataLoader for N+1 prevention\",\n      \"Input validation\",\n      \"Error handling\",\n      \"Authentication middleware\",\n      \"Field-level permissions\"\n    ],\n    \"technical_requirements\": {\n      \"typescript\": \"strict mode\",\n      \"schema_first\": true,\n      \"codegen\": \"graphql-codegen for types\",\n      \"testing\": \"jest with graphql-test-utils\"\n    }\n  },\n  \"acceptance_criteria\": [\n    \"All schema types properly defined with TypeScript integration\",\n    \"Resolvers implemented with proper error handling\",\n    \"N+1 query prevention implemented with DataLoader\",\n    \"Authentication and authorization working\",\n    \"All operations tested with >90% coverage\",\n    \"GraphQL Playground documentation complete\",\n    \"Performance testing shows <100ms response time\"\n  ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-file-upload",
        "context": "{\"previous_phase\": \"architecture\", \"api_spec\": \"File upload to AWS S3 with presigned URLs\", \"database\": \"PostgreSQL for metadata\", \"framework\": \"Express.js + AWS SDK\"}",
        "reasoning": "For implementing secure file uploads to AWS S3, I'll assign this to a backend-dev drone who specializes in cloud integration. The task requires careful handling of presigned URLs, security considerations, and proper metadata tracking. The implementation needs to cover both direct uploads and metadata management, with strong validation and error handling.",
        "drone_task": "{\n    \"drone_id\": \"backend-dev\",\n    \"task_type\": \"implement-file-upload\",\n    \"description\": \"Implement secure file upload system using AWS S3 presigned URLs\",\n    \"payload\": {\n        \"endpoints\": [\n            {\"method\": \"POST\", \"path\": \"/api/files/request-upload\", \"description\": \"Get presigned URL\"},\n            {\"method\": \"POST\", \"path\": \"/api/files/complete\", \"description\": \"Confirm upload completion\"},\n            {\"method\": \"GET\", \"path\": \"/api/files/:id\", \"description\": \"Get file metadata\"}\n        ],\n        \"features\": [\n            \"presigned URL generation\",\n            \"mime type validation\",\n            \"file size limits\",\n            \"metadata tracking\",\n            \"error handling\"\n        ],\n        \"security\": {\n            \"max_file_size\": \"100MB\",\n            \"allowed_types\": [\"image/*\", \"application/pdf\"],\n            \"url_expiration\": \"15 minutes\"\n        },\n        \"database\": {\n            \"metadata_fields\": [\"filename\", \"size\", \"type\", \"url\", \"user_id\", \"status\"]\n        }\n    },\n    \"acceptance_criteria\": [\n        \"Presigned URLs successfully generate and work with S3\",\n        \"File metadata correctly stored in PostgreSQL\",\n        \"Input validation prevents unauthorized file types\",\n        \"Error handling covers network and S3 failures\",\n        \"Upload progress tracking implemented\",\n        \"Security headers and CORS properly configured\"\n    ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-real-time",
        "context": "{\"previous_phase\": \"design\", \"api_spec\": \"WebSocket server for real-time notifications\", \"database\": \"Redis for pub/sub\", \"framework\": \"Socket.io + Express\"}",
        "reasoning": "For implementing real-time functionality with WebSocket and Redis pub/sub, I'll assign this to a backend-dev drone. The task requires expertise in WebSocket protocols, Redis pub/sub patterns, and connection management. The drone will need to implement bidirectional communication, handle connection states, and ensure scalable message delivery.",
        "drone_task": "{\n    \"drone_id\": \"backend-dev\",\n    \"task_type\": \"implement-real-time\",\n    \"description\": \"Implement WebSocket server with Redis pub/sub for real-time notifications\",\n    \"payload\": {\n        \"components\": {\n            \"websocket\": {\n                \"connection_handling\": [\"authentication\", \"heartbeat\", \"reconnection\"],\n                \"events\": [\"connect\", \"disconnect\", \"message\", \"error\"],\n                \"rooms\": [\"user-specific\", \"broadcast\", \"topic-based\"]\n            },\n            \"redis\": {\n                \"pub_sub\": [\"channel setup\", \"message serialization\", \"subscription management\"],\n                \"persistence\": [\"temporary message storage\", \"offline queue\"]\n            },\n            \"features\": [\n                \"presence detection\",\n                \"message acknowledgment\",\n                \"client state tracking\",\n                \"error handling\"\n            ]\n        },\n        \"scaling\": {\n            \"connection_limits\": \"10000 concurrent\",\n            \"message_rate\": \"1000/second\"\n        }\n    },\n    \"acceptance_criteria\": [\n        \"WebSocket server successfully handles connections and disconnections\",\n        \"Redis pub/sub properly distributes messages across channels\",\n        \"Authentication and authorization working for socket connections\",\n        \"Message delivery confirmation implemented\",\n        \"Error handling and reconnection logic verified\",\n        \"Load testing shows stable performance under specified limits\"\n    ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-search",
        "context": "{\"previous_phase\": \"architecture\", \"api_spec\": \"Full-text search with Elasticsearch\", \"database\": \"Elasticsearch for search index\", \"framework\": \"Express.js + Elasticsearch client\"}",
        "reasoning": "For implementing search functionality with Elasticsearch, I'll assign this to a backend-dev drone who specializes in search implementations. The task requires expertise in both Express.js integration and Elasticsearch configuration. The task will be structured to ensure proper index setup, query optimization, and search result relevance. Key focus areas include mapping configuration, search query implementation, and relevance tuning.",
        "drone_task": "{\n    \"drone_id\": \"backend-dev\",\n    \"task_type\": \"implement-search\",\n    \"description\": \"Implement full-text search functionality using Elasticsearch\",\n    \"payload\": {\n        \"index_setup\": {\n            \"mappings\": [\"text fields\", \"keyword fields\", \"nested objects\"],\n            \"analyzers\": [\"standard\", \"ngram\", \"custom stopwords\"]\n        },\n        \"endpoints\": [\n            {\"method\": \"POST\", \"path\": \"/api/search\", \"features\": [\"pagination\", \"filtering\", \"sorting\"]},\n            {\"method\": \"POST\", \"path\": \"/api/search/suggest\", \"features\": [\"autocomplete\"]}\n        ],\n        \"features\": [\n            \"fuzzy matching\",\n            \"highlighting\",\n            \"faceted search\",\n            \"relevance scoring\",\n            \"result pagination\"\n        ],\n        \"performance\": {\n            \"response_time\": \"<200ms\",\n            \"bulk_indexing\": \"batch processing\"\n        }\n    },\n    \"acceptance_criteria\": [\n        \"Search index properly configured with mappings\",\n        \"Fuzzy search working with configurable threshold\",\n        \"Search results properly paginated and sorted\",\n        \"Response time under 200ms for typical queries\",\n        \"Proper error handling for failed searches\",\n        \"Relevance scoring tuned for accuracy\",\n        \"Documentation for search API endpoints\"\n    ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-caching",
        "context": "{\"previous_phase\": \"design\", \"api_spec\": \"Redis caching layer for API responses\", \"database\": \"Redis for cache\", \"framework\": \"Express.js with caching middleware\"}",
        "reasoning": "For implementing a caching layer, I'll assign this to a backend-dev drone who specializes in performance optimization and middleware implementation. The task requires careful consideration of cache invalidation strategies, TTL settings, and integration with the existing API framework. The drone will need to implement both the caching middleware and monitoring capabilities to ensure the caching system is working effectively.",
        "drone_task": "{\n    \"drone_id\": \"backend-dev\",\n    \"task_type\": \"implement-caching\",\n    \"description\": \"Implement Redis caching layer with intelligent invalidation\",\n    \"payload\": {\n        \"cache_strategy\": {\n            \"type\": \"Redis\",\n            \"ttl\": \"configurable per endpoint\",\n            \"patterns\": [\"GET endpoints\", \"frequently accessed data\"]\n        },\n        \"features\": [\n            \"cache middleware\",\n            \"automatic invalidation\",\n            \"cache warming\",\n            \"hit rate monitoring\"\n        ],\n        \"implementation\": {\n            \"middleware\": \"Express cache middleware\",\n            \"key_generation\": \"based on URL + query params + auth\",\n            \"invalidation\": \"on POST/PUT/DELETE operations\",\n            \"monitoring\": \"cache hit/miss metrics\"\n        },\n        \"cache_controls\": {\n            \"max_size\": \"1GB per cache type\",\n            \"compression\": \"for large responses\",\n            \"bypass_header\": \"Cache-Control: no-cache\"\n        }\n    },\n    \"acceptance_criteria\": [\n        \"Cache hit rate >80% for eligible endpoints\",\n        \"Response time improved by >50% for cached routes\",\n        \"Proper cache invalidation on data updates\",\n        \"Memory usage within defined limits\",\n        \"Cache bypass mechanism working\",\n        \"Monitoring dashboard showing cache metrics\"\n    ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-queue",
        "context": "{\"previous_phase\": \"architecture\", \"api_spec\": \"Background job processing with Bull\", \"database\": \"Redis for Bull queue\", \"framework\": \"Node.js + Bull\"}",
        "reasoning": "For implementing a queue system with Bull, I'll assign this to a backend-dev drone since it requires deep knowledge of asynchronous processing, Redis integration, and Node.js background jobs. The task needs to focus on reliable job processing, error handling, and monitoring capabilities. The drone will need to implement job queues, workers, and error recovery mechanisms.",
        "drone_task": "{\n  \"drone_id\": \"backend-dev\",\n  \"task_type\": \"implement-queue\",\n  \"description\": \"Implement Bull queue system for background job processing\",\n  \"payload\": {\n    \"components\": {\n      \"queues\": [\"email\", \"notification\", \"data-processing\"],\n      \"workers\": \"separate worker processes\",\n      \"monitoring\": \"Bull Board UI\",\n      \"features\": [\n        \"retry mechanism\",\n        \"job prioritization\",\n        \"rate limiting\",\n        \"concurrent processing\",\n        \"dead letter queue\"\n      ]\n    },\n    \"implementation\": {\n      \"job_definition\": \"typed job payloads\",\n      \"error_handling\": \"max retries with backoff\",\n      \"monitoring\": \"prometheus metrics\",\n      \"scaling\": \"multiple workers support\"\n    }\n  },\n  \"acceptance_criteria\": [\n    \"Queue processes jobs reliably with retries\",\n    \"Jobs can be prioritized and rate limited\",\n    \"Monitoring dashboard shows queue status\",\n    \"Failed jobs are properly logged and tracked\",\n    \"System handles concurrent job processing\",\n    \"Memory usage remains stable under load\"\n  ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-webhook",
        "context": "{\"previous_phase\": \"design\", \"api_spec\": \"Webhook system for third-party integrations\", \"database\": \"PostgreSQL for webhook subscriptions\", \"framework\": \"Express.js + Bull for delivery\"}",
        "reasoning": "For implementing a webhook system, I'll assign this to a backend-dev drone as it requires API development, database integration, and queue management. The task needs to ensure reliable webhook delivery with retries, security measures, and proper error handling. The drone will need to implement both the subscription management and delivery mechanism.",
        "drone_task": "{\n    \"drone_id\": \"backend-dev\",\n    \"task_type\": \"implement-webhook\",\n    \"description\": \"Implement webhook system with subscription management and reliable delivery\",\n    \"payload\": {\n        \"endpoints\": [\n            {\"method\": \"POST\", \"path\": \"/api/webhooks/subscribe\"},\n            {\"method\": \"GET\", \"path\": \"/api/webhooks/subscriptions\"},\n            {\"method\": \"DELETE\", \"path\": \"/api/webhooks/unsubscribe\"}\n        ],\n        \"features\": [\n            \"HMAC signature verification\",\n            \"Retry mechanism with exponential backoff\",\n            \"Dead letter queue for failed deliveries\",\n            \"Subscription management UI\",\n            \"Event filtering options\"\n        ],\n        \"database_schema\": {\n            \"webhook_subscriptions\": [\"id\", \"url\", \"secret\", \"events\", \"status\"],\n            \"webhook_deliveries\": [\"id\", \"subscription_id\", \"payload\", \"status\", \"attempts\"]\n        },\n        \"queue_config\": {\n            \"retry_attempts\": 5,\n            \"backoff\": \"exponential\",\n            \"timeout\": \"30s\"\n        }\n    },\n    \"acceptance_criteria\": [\n        \"Webhook deliveries are signed with HMAC\",\n        \"Failed deliveries retry with exponential backoff\",\n        \"Subscriptions can be managed via API\",\n        \"Events are delivered in order\",\n        \"Failed deliveries are logged and accessible\",\n        \"System handles high load gracefully\",\n        \"Webhook health monitoring implemented\"\n    ]\n}"
      },
      {
        "augmented": true,
        "phase": "implement-rate-limiting",
        "context": "{\"previous_phase\": \"architecture\", \"api_spec\": \"Rate limiting middleware with Redis\", \"database\": \"Redis for rate limit counters\", \"framework\": \"Express.js with express-rate-limit\"}",
        "reasoning": "For implementing rate limiting, I'll assign this to a backend-dev drone since it involves middleware implementation and Redis integration. The task requires careful handling of rate limit logic, storage, and response headers. The drone will need to implement both the rate limiting middleware and the Redis storage mechanism, ensuring proper error handling and header responses.",
        "drone_task": "{\n    \"drone_id\": \"backend-dev\",\n    \"task_type\": \"implement-rate-limiting\",\n    \"description\": \"Implement Redis-backed rate limiting middleware\",\n    \"payload\": {\n        \"components\": {\n            \"middleware\": \"express-rate-limit with Redis store\",\n            \"storage\": \"Redis for distributed rate limiting\",\n            \"headers\": [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\", \"X-RateLimit-Reset\"],\n            \"limits\": {\n                \"default\": \"100 requests per 15 minutes\",\n                \"authenticated\": \"1000 requests per 15 minutes\",\n                \"admin\": \"unlimited\"\n            }\n        },\n        \"features\": [\n            \"sliding window algorithm\",\n            \"custom response messages\",\n            \"bypass tokens for internal services\",\n            \"dynamic rate adjustment\"\n        ],\n        \"error_handling\": {\n            \"429_response\": \"Too Many Requests with retry-after\",\n            \"redis_failure\": \"fallback to memory store\"\n        }\n    },\n    \"acceptance_criteria\": [\n        \"Rate limits correctly enforce request quotas\",\n        \"Redis storage properly tracks limits across instances\",\n        \"Rate limit headers present in all responses\",\n        \"Different limits applied based on user role\",\n        \"Graceful handling of Redis connection issues\",\n        \"Documentation of rate limit configuration\"\n    ]\n}"
      }
    ],
    "signature": {
      "instructions": "Delegate task to drone agent with clear instructions.\n\nYou are a Princess agent coordinating your specialized drone hive.\nYour role is to take high-level workflow phases and convert them\ninto specific, actionable tasks for your drone agents.\n\nPrincess-Dev drones: coder, reviewer, debugger, integration-engineer\nPrincess-Quality drones: tester, nasa-enforcer, theater-detector, fsm-analyzer\nPrincess-Coordination drones: orchestrator, planner, cost-tracker\n\nEach drone task must have:\n- Specific drone agent assignment\n- Task type matching drone capabilities\n- Clear context from previous phases\n- Concrete deliverables\n- Quality gates/acceptance criteria\n\nFollow the 26 prompt engineering principles:\n- Clarity: Unambiguous instructions\n- Context: Include relevant phase results\n- Constraints: Respect drone capabilities\n- Structure: Output valid JSON format",
      "fields": [
        {
          "prefix": "Phase:",
          "description": "Development phase to execute (design, code, test, review, etc.)"
        },
        {
          "prefix": "Context:",
          "description": "Context and results from previous phases that this phase depends on"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "Delegation reasoning explaining drone selection and task structure"
        },
        {
          "prefix": "Drone Task:",
          "description": "Structured task for drone agent as JSON object. Must have: {'drone_id': str, 'task_type': str, 'description': str, 'payload': dict, 'acceptance_criteria': list[str]}"
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.12",
      "dspy": "3.0.3",
      "cloudpickle": "3.0"
    }
  }
}
