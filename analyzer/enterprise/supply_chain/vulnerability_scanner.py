from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Union, Tuple, Callable, Set

from analyzer.constants.thresholds import API_TIMEOUT_SECONDS, DAYS_RETENTION_PERIOD

import json
import hashlib
import asyncio
import aiohttp
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
import re
import subprocess
import os

class VulnerabilityScanner:
    """Enterprise vulnerability scanning and license compliance engine."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.output_dir = Path(config.get('output_dir', '.claude/.artifacts/supply_chain'))
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Vulnerability databases
        self.nvd_api_key = config.get('nvd_api_key')
        self.osv_api_url = "https://api.osv.dev/v1"
        self.github_api_key = config.get('github_api_key')
        
        # License compliance
        self.allowed_licenses = set(config.get('allowed_licenses', [
            'MIT', 'Apache-2.0', 'BSD-3-Clause', 'ISC', 'BSD-2-Clause'
        ]))
        self.restricted_licenses = set(config.get('restricted_licenses', [
            'GPL-3.0', 'AGPL-3.0', 'LGPL-3.0', 'CDDL-1.0'
        ]))
        self.prohibited_licenses = set(config.get('prohibited_licenses', [
            'SSPL-1.0', 'Commons-Clause', 'Elastic-2.0'
        ]))
        
        # Severity thresholds
        self.severity_thresholds = {
            'critical': config.get('critical_threshold', 9.0),
            'high': config.get('high_threshold', float(DAYS_RETENTION_PERIOD)),
            'medium': config.get('medium_threshold', 4.0)
        }
        
    async def scan_vulnerabilities(self, components: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Scan components for known vulnerabilities."""
        
        scan_results = {
            'scan_timestamp': datetime.now(timezone.utc).isoformat(),
            'total_components': len(components),
            'vulnerabilities': [],
            'summary': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'total': 0
            },
            'license_compliance': await self.check_license_compliance(components),
            'components_scanned': []
        }
        
        # Scan each component
        async with aiohttp.ClientSession() as session:
            tasks = []
            for component in components:
                if component.get('ecosystem') in ['npm', 'pypi', 'maven', 'nuget']:
                    task = self._scan_component_vulnerabilities(session, component)
                    tasks.append(task)
            
            component_results = await asyncio.gather(*tasks, return_exceptions=True)
            
        # Process results
        for i, result in enumerate(component_results):
            if isinstance(result, Exception):
                continue
                
            if result:
                scan_results['components_scanned'].append(result['component'])
                
                for vuln in result.get('vulnerabilities', []):
                    scan_results['vulnerabilities'].append(vuln)
                    severity = vuln.get('severity', 'unknown').lower()
                    if severity in scan_results['summary']:
                        scan_results['summary'][severity] += 1
                    scan_results['summary']['total'] += 1
        
        # Save scan results
        results_path = self.output_dir / "vulnerability-scan.json"
        with open(results_path, 'w', encoding='utf-8') as f:
            json.dump(scan_results, f, indent=2, ensure_ascii=False)
            
        return scan_results
    
    async def _scan_component_vulnerabilities(self, 
                                            session: aiohttp.ClientSession,
                                            component: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Scan individual component for vulnerabilities."""
        
        component_result = {
            'component': {
                'name': component.get('name'),
                'version': component.get('version'),
                'ecosystem': component.get('ecosystem'),
                'purl': component.get('purl')
            },
            'vulnerabilities': []
        }
        
        try:
            # Query OSV database
            osv_vulns = await self._query_osv_database(session, component)
            component_result['vulnerabilities'].extend(osv_vulns)
            
            # Query GitHub Security Advisory if available
            if self.github_api_key and component.get('ecosystem') == 'npm':
                github_vulns = await self._query_github_advisories(session, component)
                component_result['vulnerabilities'].extend(github_vulns)
            
            # Deduplicate vulnerabilities
            component_result['vulnerabilities'] = self._deduplicate_vulnerabilities(
                component_result['vulnerabilities']
            )
            
        except Exception as e:
            print(f"Error scanning {component.get('name')}: {e}")
            
        return component_result
    
    async def _query_osv_database(self, 
                                session: aiohttp.ClientSession,
                                component: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Query OSV (Open Source Vulnerabilities) database."""
        
        vulnerabilities = []
        
        try:
            query_data = {
                "package": {
                    "name": component.get('name'),
                    "ecosystem": self._map_ecosystem_to_osv(component.get('ecosystem'))
                }
            }
            
            if component.get('version'):
                query_data["version"] = component['version']
            
            async with session.post(
                f"{self.osv_api_url}/query",
                json=query_data,
                timeout=aiohttp.ClientTimeout(total=API_TIMEOUT_SECONDS)
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for vuln in data.get('vulns', []):
                        processed_vuln = self._process_osv_vulnerability(vuln, component)
                        if processed_vuln:
                            vulnerabilities.append(processed_vuln)
                            
        except Exception as e:
            print(f"Error querying OSV for {component.get('name')}: {e}")
            
        return vulnerabilities
    
    async def _query_github_advisories(self, 
                                    session: aiohttp.ClientSession,
                                    component: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Query GitHub Security Advisories."""
        
        vulnerabilities = []
        
        try:
            headers = {
                'Authorization': f'token {self.github_api_key}',
                'Accept': 'application/vnd.github.v3+json'
            }
            
            # Search for advisories
            query = f"type:reviewed ecosystem:npm {component.get('name')}"
            
            async with session.get(
                f"https://api.github.com/search/advisories?q={query}",
                headers=headers,
                timeout=aiohttp.ClientTimeout(total=API_TIMEOUT_SECONDS)
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for advisory in data.get('items', []):
                        processed_vuln = self._process_github_advisory(advisory, component)
                        if processed_vuln:
                            vulnerabilities.append(processed_vuln)
                            
        except Exception as e:
            print(f"Error querying GitHub advisories for {component.get('name')}: {e}")
            
        return vulnerabilities
    
    def _process_osv_vulnerability(self, 
                                    vuln_data: Dict[str, Any],
                                    component: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Process OSV vulnerability data."""
        
        try:
            # Check if component version is affected
            if not self._is_version_affected(component.get('version'), vuln_data):
                return None
            
            # Extract severity
            severity = self._extract_severity_from_osv(vuln_data)
            
            return {
                'id': vuln_data.get('id'),
                'source': 'OSV',
                'summary': vuln_data.get('summary', ''),
                'details': vuln_data.get('details', ''),
                'severity': severity,
                'cvss_score': self._extract_cvss_score(vuln_data),
                'published': vuln_data.get('published'),
                'modified': vuln_data.get('modified'),
                'aliases': vuln_data.get('aliases', []),
                'references': [ref.get('url') for ref in vuln_data.get('references', [])],
                'affected_versions': self._extract_affected_versions(vuln_data),
                'fixed_versions': self._extract_fixed_versions(vuln_data)
            }
            
        except Exception as e:
            print(f"Error processing OSV vulnerability: {e}")
            return None
    
    def _process_github_advisory(self, 
                                advisory: Dict[str, Any],
                                component: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Process GitHub Security Advisory."""
        
        try:
            return {
                'id': advisory.get('ghsa_id'),
                'source': 'GitHub',
                'summary': advisory.get('summary', ''),
                'details': advisory.get('description', ''),
                'severity': advisory.get('severity', '').lower(),
                'cvss_score': advisory.get('cvss', {}).get('score'),
                'published': advisory.get('published_at'),
                'modified': advisory.get('updated_at'),
                'aliases': advisory.get('cve_id') and [advisory['cve_id']] or [],
                'references': [advisory.get('html_url')],
                'affected_versions': self._extract_github_affected_versions(advisory),
                'fixed_versions': []  # GitHub API doesn't always provide this
            }
            
        except Exception as e:
            print(f"Error processing GitHub advisory: {e}")
            return None
    
    def _is_version_affected(self, version: str, vuln_data: Dict[str, Any]) -> bool:
        """Check if component version is affected by vulnerability."""
        
        if not version:
            return True  # Assume affected if no version specified
        
        try:
            affected_ranges = vuln_data.get('affected', [])
            
            for affected in affected_ranges:
                ranges = affected.get('ranges', [])
                for range_data in ranges:
                    if self._version_in_range(version, range_data):
                        return True
                        
        except Exception as e:
            print(f"Error checking version affected: {e}")
            
        return False
    
    def _version_in_range(self, version: str, range_data: Dict[str, Any]) -> bool:
        """Check if version falls within vulnerability range."""
        
        try:
            range_type = range_data.get('type', 'SEMVER')
            events = range_data.get('events', [])
            
            if range_type == 'SEMVER':
                return self._semver_in_range(version, events)
            elif range_type == 'ECOSYSTEM':
                return self._ecosystem_version_in_range(version, events)
                
        except Exception:
            pass
            
        return True  # Assume affected if can't determine
    
    def _semver_in_range(self, version: str, events: List[Dict[str, Any]]) -> bool:
        """Check if semantic version is in vulnerability range."""
        
        try:
            from packaging import version as pkg_version
            
            current_version = pkg_version.parse(version)
            in_vulnerable_range = False
            
            for event in events:
                if event.get('introduced'):
                    introduced = pkg_version.parse(event['introduced'])
                    if current_version >= introduced:
                        in_vulnerable_range = True
                
                if event.get('fixed'):
                    fixed = pkg_version.parse(event['fixed'])
                    if current_version >= fixed:
                        in_vulnerable_range = False
                        
        except Exception:
            return True  # Assume vulnerable if can't parse
            
        return in_vulnerable_range
    
    def _ecosystem_version_in_range(self, version: str, events: List[Dict[str, Any]]) -> bool:
        """Check if ecosystem-specific version is in range."""
        # Simplified implementation - in production, use ecosystem-specific logic
        return True
    
    def _extract_severity_from_osv(self, vuln_data: Dict[str, Any]) -> str:
        """Extract severity from OSV vulnerability data."""
        
        # Check severity field
        if 'severity' in vuln_data:
            severities = vuln_data['severity']
            if isinstance(severities, list) and severities:
                return severities[0].get('type', 'unknown').lower()
        
        # Check database_specific for severity
        db_specific = vuln_data.get('database_specific', {})
        if 'severity' in db_specific:
            return db_specific['severity'].lower()
        
        # Infer from CVSS score
        cvss_score = self._extract_cvss_score(vuln_data)
        if cvss_score:
            return self._cvss_to_severity(cvss_score)
        
        return 'unknown'
    
    def _extract_cvss_score(self, vuln_data: Dict[str, Any]) -> Optional[float]:
        """Extract CVSS score from vulnerability data."""
        
        # Check severity array
        severities = vuln_data.get('severity', [])
        for severity in severities:
            if severity.get('type') == 'CVSS_V3' and 'score' in severity:
                return severity['score']
        
        # Check database_specific
        db_specific = vuln_data.get('database_specific', {})
        if 'cvss' in db_specific:
            cvss = db_specific['cvss']
            if isinstance(cvss, dict) and 'baseScore' in cvss:
                return cvss['baseScore']
        
        return None
    
    def _cvss_to_severity(self, score: float) -> str:
        """Convert CVSS score to severity level."""
        if score >= self.severity_thresholds['critical']:
            return 'critical'
        elif score >= self.severity_thresholds['high']:
            return 'high'
        elif score >= self.severity_thresholds['medium']:
            return 'medium'
        else:
            return 'low'
    
    def _extract_affected_versions(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract affected version ranges."""
        affected_versions = []
        
        try:
            affected = vuln_data.get('affected', [])
            for item in affected:
                versions = item.get('versions', [])
                affected_versions.extend(versions)
        except Exception:
            pass
            
        return affected_versions
    
    def _extract_fixed_versions(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract fixed versions from vulnerability data."""
        fixed_versions = []
        
        try:
            affected = vuln_data.get('affected', [])
            for item in affected:
                ranges = item.get('ranges', [])
                for range_data in ranges:
                    events = range_data.get('events', [])
                    for event in events:
                        if event.get('fixed'):
                            fixed_versions.append(event['fixed'])
        except Exception:
            pass
            
        return fixed_versions
    
    def _extract_github_affected_versions(self, advisory: Dict[str, Any]) -> List[str]:
        """Extract affected versions from GitHub advisory."""
        # Simplified implementation
        return []
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Remove duplicate vulnerabilities."""
        seen_ids = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            vuln_id = vuln.get('id')
            if vuln_id and vuln_id not in seen_ids:
                seen_ids.add(vuln_id)
                unique_vulns.append(vuln)
            elif not vuln_id:
                # Keep vulnerabilities without IDs
                unique_vulns.append(vuln)
        
        return unique_vulns
    
    def _map_ecosystem_to_osv(self, ecosystem: str) -> str:
        """Map internal ecosystem names to OSV ecosystem names."""
        mapping = {
            'npm': 'npm',
            'pypi': 'PyPI',
            'maven': 'Maven',
            'nuget': 'NuGet',
            'go': 'Go',
            'cargo': 'crates.io'
        }
        return mapping.get(ecosystem, ecosystem)
    
    async def check_license_compliance(self, components: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Check license compliance for components."""
        
        compliance_result = {
            'scan_timestamp': datetime.now(timezone.utc).isoformat(),
            'total_components': len(components),
            'compliant': 0,
            'non_compliant': 0,
            'unknown_license': 0,
            'violations': [],
            'warnings': [],
            'summary': {
                'allowed': 0,
                'restricted': 0,
                'prohibited': 0,
                'unknown': 0
            }
        }
        
        for component in components:
            licenses = component.get('licenses', [])
            
            if not licenses:
                compliance_result['unknown_license'] += 1
                compliance_result['summary']['unknown'] += 1
                compliance_result['warnings'].append({
                    'component': component.get('name'),
                    'version': component.get('version'),
                    'issue': 'Unknown or missing license'
                })
                continue
            
            component_status = self._check_component_license_compliance(component, licenses)
            
            if component_status['compliant']:
                compliance_result['compliant'] += 1
            else:
                compliance_result['non_compliant'] += 1
                compliance_result['violations'].extend(component_status['violations'])
            
            # Update summary
            for license_type in component_status['license_types']:
                compliance_result['summary'][license_type] += 1
        
        return compliance_result
    
    def _check_component_license_compliance(self, 
                                            component: Dict[str, Any],
                                            licenses: List[str]) -> Dict[str, Any]:
        """Check license compliance for a single component."""
        
        result = {
            'compliant': True,
            'violations': [],
            'license_types': []
        }
        
        for license_id in licenses:
            license_type = self._categorize_license(license_id)
            result['license_types'].append(license_type)
            
            if license_type == 'prohibited':
                result['compliant'] = False
                result['violations'].append({
                    'component': component.get('name'),
                    'version': component.get('version'),
                    'license': license_id,
                    'violation_type': 'prohibited',
                    'severity': 'critical',
                    'description': f'Component uses prohibited license: {license_id}'
                })
            
            elif license_type == 'restricted':
                # Restricted licenses require review
                result['violations'].append({
                    'component': component.get('name'),
                    'version': component.get('version'),
                    'license': license_id,
                    'violation_type': 'restricted',
                    'severity': 'medium',
                    'description': f'Component uses restricted license requiring review: {license_id}'
                })
        
        return result
    
    def _categorize_license(self, license_id: str) -> str:
        """Categorize license based on compliance rules."""
        
        if license_id in self.prohibited_licenses:
            return 'prohibited'
        elif license_id in self.restricted_licenses:
            return 'restricted'
        elif license_id in self.allowed_licenses:
            return 'allowed'
        else:
            return 'unknown'
    
    def generate_compliance_report(self, scan_results: Dict[str, Any]) -> str:
        """Generate comprehensive compliance report."""
        
        report_data = {
            'scan_metadata': {
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'scan_type': 'Vulnerability and License Compliance',
                'tool': 'SPEK Supply Chain Security Scanner'
            },
            'vulnerability_summary': scan_results.get('summary', {}),
            'license_compliance': scan_results.get('license_compliance', {}),
            'critical_findings': self._get_critical_findings(scan_results),
            'recommendations': self._generate_recommendations(scan_results)
        }
        
        # Save report
        report_path = self.output_dir / "compliance-report.json"
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False)
            
        return str(report_path)
    
    def _get_critical_findings(self, scan_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract critical security and compliance findings."""
        
        critical_findings = []
        
        # Critical vulnerabilities
        for vuln in scan_results.get('vulnerabilities', []):
            if vuln.get('severity') == 'critical':
                critical_findings.append({
                    'type': 'vulnerability',
                    'severity': 'critical',
                    'component': vuln.get('component', {}),
                    'issue': vuln.get('summary', ''),
                    'id': vuln.get('id')
                })
        
        # License violations
        license_compliance = scan_results.get('license_compliance', {})
        for violation in license_compliance.get('violations', []):
            if violation.get('violation_type') == 'prohibited':
                critical_findings.append({
                    'type': 'license_violation',
                    'severity': 'critical',
                    'component': violation.get('component'),
                    'issue': violation.get('description'),
                    'license': violation.get('license')
                })
        
        return critical_findings
    
    def _generate_recommendations(self, scan_results: Dict[str, Any]) -> List[str]:
        """Generate actionable recommendations."""
        
        recommendations = []
        
        # Vulnerability recommendations
        vuln_summary = scan_results.get('summary', {})
        if vuln_summary.get('critical', 0) > 0:
            recommendations.append(
                f"URGENT: Address {vuln_summary['critical']} critical vulnerabilities immediately"
            )
        
        if vuln_summary.get('high', 0) > 0:
            recommendations.append(
                f"Update {vuln_summary['high']} components with high-severity vulnerabilities"
            )
        
        # License recommendations
        license_compliance = scan_results.get('license_compliance', {})
        if license_compliance.get('non_compliant', 0) > 0:
            recommendations.append(
                f"Review {license_compliance['non_compliant']} components with license violations"
            )
        
        if license_compliance.get('unknown_license', 0) > 0:
            recommendations.append(
                f"Identify licenses for {license_compliance['unknown_license']} components"
            )
        
        return recommendations