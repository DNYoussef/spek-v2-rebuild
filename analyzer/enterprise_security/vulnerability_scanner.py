from typing import Any, Dict, List, Optional, Union, Tuple, Callable, Set

"""
Advanced Vulnerability Scanner
Enhanced security scanning with pattern matching and AST analysis.
"""

from typing import List, Dict, Any, Optional
import ast
import json
import os
import re

from .scanner import SecurityVulnerability, VulnerabilityType, SecurityLevel
from dataclasses import dataclass

class VulnerabilityScanner:
    """Advanced vulnerability scanner with AST analysis."""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}

    def scan_ast_vulnerabilities(self, file_path: str, content: str) -> List[SecurityVulnerability]:
        """Scan using AST analysis for more accurate detection."""
        vulnerabilities = []

        try:
            tree = ast.parse(content)

            for node in ast.walk(tree):
                # Check for dangerous function calls
                if isinstance(node, ast.Call):
                    vulnerabilities.extend(self._analyze_function_call(file_path, node, content))

                # Check for dangerous imports
                if isinstance(node, ast.Import):
                    vulnerabilities.extend(self._analyze_import(file_path, node))

                # Check for dangerous string operations
                if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add):
                    vulnerabilities.extend(self._analyze_string_concat(file_path, node, content))

        except SyntaxError:
            # File has syntax errors, fall back to regex scanning
            pass

        return vulnerabilities

    def _analyze_function_call(self, file_path: str, node: ast.Call, content: str) -> List[SecurityVulnerability]:
        """Analyze function calls for security issues."""
        vulnerabilities = []

        # Get function name
        func_name = ""
        if isinstance(node.func, ast.Name):
            func_name = node.func.id
        elif isinstance(node.func, ast.Attribute):
            func_name = f"{self._get_attr_name(node.func)}"

        # Dangerous functions
        dangerous_functions = {
            'eval': (VulnerabilityType.COMMAND_INJECTION, SecurityLevel.CRITICAL, "CWE-95"),
            'exec': (VulnerabilityType.COMMAND_INJECTION, SecurityLevel.CRITICAL, "CWE-95"),
            'compile': (VulnerabilityType.COMMAND_INJECTION, SecurityLevel.HIGH, "CWE-95"),
            'os.system': (VulnerabilityType.COMMAND_INJECTION, SecurityLevel.HIGH, "CWE-78"),
            'subprocess.call': (VulnerabilityType.COMMAND_INJECTION, SecurityLevel.MEDIUM, "CWE-78"),
            'pickle.loads': (VulnerabilityType.UNSAFE_DESERIALIZATION, SecurityLevel.HIGH, "CWE-502"),
            'yaml.load': (VulnerabilityType.UNSAFE_DESERIALIZATION, SecurityLevel.HIGH, "CWE-502"),
        }

        if func_name in dangerous_functions:
            vuln_type, severity, cwe_id = dangerous_functions[func_name]
            line_num = getattr(node, 'lineno', 1)

            vulnerabilities.append(SecurityVulnerability(
                vuln_type=vuln_type,
                severity=severity,
                file_path=file_path,
                line_number=line_num,
                description=f"Dangerous function call: {func_name}",
                evidence={"function": func_name},
                recommendation=f"Avoid using {func_name} or validate input thoroughly",
                cwe_id=cwe_id,
                confidence=0.9
            ))

        return vulnerabilities

    def _analyze_import(self, file_path: str, node: ast.Import) -> List[SecurityVulnerability]:
        """Analyze imports for security issues."""
        vulnerabilities = []

        dangerous_imports = {
            'pickle': "Unsafe deserialization library",
            'cPickle': "Unsafe deserialization library",
            'subprocess': "Command execution library - review usage",
            'os': "System access library - review usage",
        }

        for alias in node.names:
            if alias.name in dangerous_imports:
                vulnerabilities.append(SecurityVulnerability(
                    vuln_type=VulnerabilityType.IMPROPER_VALIDATION,
                    severity=SecurityLevel.INFO,
                    file_path=file_path,
                    line_number=getattr(node, 'lineno', 1),
                    description=f"Potentially dangerous import: {alias.name}",
                    evidence={"import": alias.name, "reason": dangerous_imports[alias.name]},
                    recommendation="Review usage of this library for security implications",
                    confidence=0.5
                ))

        return vulnerabilities

    def _analyze_string_concat(self, file_path: str, node: ast.BinOp, content: str) -> List[SecurityVulnerability]:
        """Analyze string concatenation for SQL injection risks."""
        vulnerabilities = []

        # Check if this looks like SQL concatenation
        line_num = getattr(node, 'lineno', 1)
        lines = content.split('\n')
        if line_num <= len(lines):
            line_content = lines[line_num - 1].lower()

            sql_keywords = ['select', 'insert', 'update', 'delete', 'from', 'where', 'join']
            if any(keyword in line_content for keyword in sql_keywords):
                vulnerabilities.append(SecurityVulnerability(
                    vuln_type=VulnerabilityType.SQL_INJECTION,
                    severity=SecurityLevel.HIGH,
                    file_path=file_path,
                    line_number=line_num,
                    description="Potential SQL injection through string concatenation",
                    evidence={"line": line_content.strip()},
                    recommendation="Use parameterized queries instead of string concatenation",
                    cwe_id="CWE-89",
                    confidence=0.7
                ))

        return vulnerabilities

    def _get_attr_name(self, node: ast.Attribute) -> str:
        """Get the full attribute name from an AST node."""
        if isinstance(node.value, ast.Name):
            return f"{node.value.id}.{node.attr}"
        elif isinstance(node.value, ast.Attribute):
            return f"{self._get_attr_name(node.value)}.{node.attr}"
        else:
            return node.attr

    def scan_dependency_vulnerabilities(self, directory: str) -> List[SecurityVulnerability]:
        """Scan for known vulnerable dependencies."""
        vulnerabilities = []

        # Check requirements.txt
        req_file = os.path.join(directory, 'requirements.txt')
        if path_exists(req_file):
            vulnerabilities.extend(self._scan_requirements_file(req_file))

        # Check package.json
        package_file = os.path.join(directory, 'package.json')
        if path_exists(package_file):
            vulnerabilities.extend(self._scan_package_json(package_file))

        return vulnerabilities

    def _scan_requirements_file(self, file_path: str) -> List[SecurityVulnerability]:
        """Scan requirements.txt for vulnerable packages."""
        vulnerabilities = []

        # Known vulnerable packages (simplified list)
        vulnerable_packages = {
            'django': {'<2.2.28': 'CVE-2022-28346'},
            'flask': {'<2.0.3': 'CVE-2022-550'},
            'requests': {'<2.20.0': 'CVE-2018-18074'},
            'pyyaml': {'<5.4': 'CVE-2020-14343'},
        }

        try:
            with open(file_path, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        # Parse package name and version
                        if '==' in line:
                            package, version = line.split('==', 1)
                            package = package.strip()
                            version = version.strip()

                            if package.lower() in vulnerable_packages:
                                vulns = vulnerable_packages[package.lower()]
                                for vuln_version, cve in vulns.items():
                                    if self._version_vulnerable(version, vuln_version):
                                        vulnerabilities.append(SecurityVulnerability(
                                            vuln_type=VulnerabilityType.WEAK_AUTHENTICATION,
                                            severity=SecurityLevel.HIGH,
                                            file_path=file_path,
                                            line_number=line_num,
                                            description=f"Vulnerable dependency: {package} {version}",
                                            evidence={"package": package, "version": version, "cve": cve},
                                            recommendation=f"Update {package} to a secure version",
                                            confidence=0.9
                                        ))

        except Exception:
            pass

        return vulnerabilities

    def _scan_package_json(self, file_path: str) -> List[SecurityVulnerability]:
        """Scan package.json for vulnerable packages."""
        vulnerabilities = []

        try:
            with open(file_path, 'r') as f:
                package_data = json.load(f)

            dependencies = package_data.get('dependencies', {})
            dev_dependencies = package_data.get('devDependencies', {})

            all_deps = {**dependencies, **dev_dependencies}

            # Known vulnerable packages (simplified)
            vulnerable_js_packages = {
                'lodash': {'<4.17.19': 'CVE-2020-8203'},
                'express': {'<4.17.3': 'CVE-2022-24999'},
                'axios': {'<0.21.1': 'CVE-2020-28168'},
            }

            for package, version in all_deps.items():
                if package in vulnerable_js_packages:
                    vulns = vulnerable_js_packages[package]
                    for vuln_version, cve in vulns.items():
                        # Simplified version check
                        clean_version = version.replace('^', '').replace('~', '')
                        if self._version_vulnerable(clean_version, vuln_version):
                            vulnerabilities.append(SecurityVulnerability(
                                vuln_type=VulnerabilityType.WEAK_AUTHENTICATION,
                                severity=SecurityLevel.MEDIUM,
                                file_path=file_path,
                                line_number=1,
                                description=f"Vulnerable JS dependency: {package} {version}",
                                evidence={"package": package, "version": version, "cve": cve},
                                recommendation=f"Update {package} to a secure version",
                                confidence=0.8
                            ))

        except Exception:
            pass

        return vulnerabilities

    def _version_vulnerable(self, current_version: str, vulnerable_spec: str) -> bool:
        """Check if current version matches vulnerable specification."""
        # Simplified version comparison
        if vulnerable_spec.startswith('<'):
            target_version = vulnerable_spec[1:]
            return current_version < target_version
        return False

    def comprehensive_scan(self, file_path: str) -> List[SecurityVulnerability]:
        """Perform comprehensive vulnerability scan."""
        if not path_exists(file_path):
            return []

        vulnerabilities = []

        if validate_file(file_path):
            # Scan single file
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                vulnerabilities.extend(self.scan_ast_vulnerabilities(file_path, content))
            except Exception:
                pass
        else:
            # Scan directory
            for root, dirs, files in os.walk(file_path):
                dirs[:] = [d for d in dirs if not d.startswith('.')]

                for file in files:
                    if file.endswith('.py'):
                        full_path = os.path.join(root, file)
                        try:
                            with open(full_path, 'r', encoding='utf-8') as f:
                                content = f.read()
                            vulnerabilities.extend(self.scan_ast_vulnerabilities(full_path, content))
                        except Exception:
                            continue

            # Scan dependencies
            vulnerabilities.extend(self.scan_dependency_vulnerabilities(file_path))

        return vulnerabilities